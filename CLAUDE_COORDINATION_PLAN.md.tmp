# Claude Code Coordination Plan for Future Projects

## Executive Summary

This plan provides a comprehensive framework for Claude Code instances to follow in future projects, addressing the critical limitations of file-based work claiming and establishing robust coordination mechanisms for concurrent automated workers. The framework emphasizes effective, efficient, tech-agnostic, failsafe, and fast workflow systems.

## Core Coordination Mechanisms

### 1. Work Claiming Evolution (`alias: work-claim`)

**Current State**: File-based claiming leads to race conditions and duplicate work
**Target State**: Distributed coordination with real-time synchronization

#### Immediate Implementation (File-Based Improvements)
```bash
# Create atomic claim files with TTL and metadata
claude-claim-task() {
    TASK_ID=$1
    AGENT_ID=$2
    CLAIM_FILE="tasks/${TASK_ID}.claim"
    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    TTL_SECONDS=300  # 5 minutes
    
    # Atomic claim with metadata
    if (set -C; echo "{\"agent\":\"${AGENT_ID}\",\"claimed_at\":\"${TIMESTAMP}\",\"ttl\":${TTL_SECONDS}}" > "${CLAIM_FILE}") 2>/dev/null; then
        echo "Task ${TASK_ID} claimed by ${AGENT_ID}"
        return 0
    else
        echo "Task ${TASK_ID} already claimed"
        return 1
    fi
}

# Heartbeat mechanism to maintain claims
claude-heartbeat() {
    AGENT_ID=$1
    while true; do
        find tasks/ -name "*.claim" -exec grep -l "\"agent\":\"${AGENT_ID}\"" {} \; | \
        while read claim_file; do
            # Update timestamp in claim file
            TASK_ID=$(basename "$claim_file" .claim)
            TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            jq --arg ts "$TIMESTAMP" '.claimed_at = $ts' "$claim_file" > "${claim_file}.tmp" && \
            mv "${claim_file}.tmp" "$claim_file"
        done
        sleep 30
    done
}
```

#### Target Implementation (Redis-Based with Enhanced Recovery)
```python
import redis
import json
import time
import subprocess
from typing import Optional

class DistributedWorkClaimer:
    def __init__(self, redis_url: str, agent_id: str):
        self.redis_url = redis_url
        self.agent_id = agent_id
        self.claim_ttl = 300  # 5 minutes
        self.redis = self._ensure_redis_connection()
    
    def _ensure_redis_connection(self, allow_fallback: bool = False) -> redis.Redis:
        """Ensure Redis is available, attempt auto-start if needed"""
        try:
            redis_client = redis.from_url(self.redis_url)
            redis_client.ping()
            return redis_client
        except (redis.ConnectionError, redis.TimeoutError):
            # Attempt to start coordination services
            if allow_fallback:
                result = subprocess.run([
                    "./scripts/service-manager.sh", "start-with-fallback", self.redis_url
                ], capture_output=True, text=True)
            else:
                result = subprocess.run([
                    "./scripts/service-manager.sh", "start", self.redis_url
                ], capture_output=True, text=True)
            
            if result.returncode == 0:
                # Retry connection after startup
                redis_client = redis.from_url(self.redis_url)
                redis_client.ping()
                return redis_client
            elif result.returncode == 2 and allow_fallback:
                # User accepted file-based fallback
                raise FallbackModeException("Operating in file-based coordination mode")
            else:
                raise RuntimeError(f"Redis unavailable and auto-start failed: {result.stderr}")

class FallbackModeException(Exception):
    """Exception raised when operating in file-based fallback mode"""
    pass

class CoordinationManager:
    """High-level coordination manager that handles both Redis and file-based modes"""
    
    def __init__(self, redis_url: str, agent_id: str, allow_fallback: bool = False):
        self.redis_url = redis_url
        self.agent_id = agent_id
        self.allow_fallback = allow_fallback
        self.mode = "unknown"
        self.claimer = None
        
        self._initialize_coordination()
    
    def _initialize_coordination(self):
        """Initialize coordination system with appropriate mode"""
        try:
            self.claimer = DistributedWorkClaimer(self.redis_url, self.agent_id, self.allow_fallback)
            self.mode = "redis"
            print(f"✅ Redis coordination mode active for agent {self.agent_id}")
        except FallbackModeException:
            self.claimer = FileBasedWorkClaimer(self.agent_id)
            self.mode = "file"
            print(f"⚠️  File-based coordination mode active for agent {self.agent_id}")
            print("   Limited functionality - no real-time coordination available")
        except Exception as e:
            if self.allow_fallback:
                self.claimer = FileBasedWorkClaimer(self.agent_id)
                self.mode = "file"
                print(f"⚠️  Falling back to file-based coordination: {e}")
            else:
                raise RuntimeError(f"Coordination initialization failed: {e}")
    
    def claim_task(self, task_id: str) -> bool:
        """Claim a task using the appropriate coordination method"""
        return self.claimer.claim_task(task_id)
    
    def is_redis_mode(self) -> bool:
        """Check if operating in Redis coordination mode"""
        return self.mode == "redis"
    
    def get_coordination_mode(self) -> str:
        """Get current coordination mode"""
        return self.mode

class FileBasedWorkClaimer:
    """Fallback file-based work claiming for when Redis is unavailable"""
    
    def __init__(self, agent_id: str):
        self.agent_id = agent_id
        self.claim_dir = "./work-claims"
        os.makedirs(self.claim_dir, exist_ok=True)
    
    def claim_task(self, task_id: str) -> bool:
        """Atomically claim a task using file-based locking"""
        claim_file = os.path.join(self.claim_dir, f"{task_id}.claim")
        
        try:
            # Atomic file creation with exclusive flag
            with open(claim_file, 'x') as f:
                claim_data = {
                    "agent_id": self.agent_id,
                    "claimed_at": time.time(),
                    "mode": "file_based",
                    "warning": "Limited coordination - check for conflicts"
                }
                json.dump(claim_data, f, indent=2)
            return True
        except FileExistsError:
            return False

# Usage Examples

## Basic Coordination (Redis Required)
```python
coordinator = CoordinationManager("redis://localhost:6379", "claude-agent-1")
if coordinator.claim_task("task-123"):
    print("Task claimed successfully")
    # Perform work...
```

## Coordination with Fallback Option
```python
coordinator = CoordinationManager(
    "redis://localhost:6379", 
    "claude-agent-1", 
    allow_fallback=True
)

if coordinator.claim_task("task-123"):
    if coordinator.is_redis_mode():
        print("Task claimed via Redis coordination")
    else:
        print("Task claimed via file-based coordination (limited functionality)")
    # Perform work...
```

## Command Line Usage

### Start with Redis Required (Default)
```bash
# Will fail if Redis/Docker cannot be started
./scripts/workflow-coordinator.sh start
```

### Start with Fallback Option
```bash
# Will prompt user if Redis unavailable
./scripts/workflow-coordinator.sh start-with-fallback
```

### Service Management
```bash
# Check current status
./scripts/workflow-coordinator.sh status

# Manual service startup with fallback
./scripts/service-manager.sh start-with-fallback

# Work recovery only
./scripts/work-recovery.sh cycle
```
